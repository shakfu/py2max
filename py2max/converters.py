"""Utilities for converting between Max patch formats."""

from __future__ import annotations

import json
import sqlite3
import textwrap
from pathlib import Path
from typing import Iterable, Optional

from .core import Patcher
from .maxref import MaxRefCache

PY_TEMPLATE = '''"""Auto-generated by py2max. Recreates {source_name} using py2max."""
from __future__ import annotations

from py2max import Box, Patcher
from py2max.common import Rect


def build(output_path: str = {default_output_repr}) -> Patcher:
    """Rebuild the patcher and write it to ``output_path``."""
    p = Patcher(output_path)
{patcher_attr_block}
{box_block}
{line_block}
    p.save_as(output_path)
    return p


if __name__ == "__main__":
    build()
'''


def _format_rect(rect: object) -> str:
    if isinstance(rect, dict):
        x = rect.get("x", 0.0)
        y = rect.get("y", 0.0)
        w = rect.get("w", 0.0)
        h = rect.get("h", 0.0)
    elif isinstance(rect, (list, tuple)) and len(rect) == 4:
        x, y, w, h = rect
    else:
        raise ValueError(f"Unsupported rect value: {rect}")
    return f"Rect({x}, {y}, {w}, {h})"


def _format_value(value: object) -> str:
    if isinstance(value, str):
        return repr(value)
    if isinstance(value, (int, float, bool)) or value is None:
        return repr(value)
    if isinstance(value, (list, tuple, dict)):
        return repr(value)
    return repr(value)


def _build_patcher_attribute_block(patcher_dict: dict) -> str:
    lines: list[str] = []
    for key, value in patcher_dict.items():
        if key in {"boxes", "lines"}:
            continue
        if key.startswith("_"):
            continue
        if key == "rect":
            formatted = _format_rect(value)
        else:
            formatted = _format_value(value)
        line = f"    p.{key} = {formatted}"
        lines.append(line)
    return "\n".join(lines) + ("\n" if lines else "")


def _format_box(box: dict) -> tuple[str, dict[str, object]]:
    if "patcher" in box:
        raise NotImplementedError("Subpatcher conversion is not yet supported")

    key_order = [
        "id",
        "maxclass",
        "text",
        "numinlets",
        "numoutlets",
        "outlettype",
        "patching_rect",
    ]

    parts: list[str] = []
    handled = set()
    post_assign: dict[str, object] = {}
    for key in key_order:
        if key not in box:
            continue
        value = box[key]
        if key == "patching_rect":
            formatted = _format_rect(value)
        elif key == "numoutlets" and value == 0:
            post_assign[key] = value
            handled.add(key)
            continue
        else:
            formatted = _format_value(value)
        parts.append(f"{key}={formatted}")
        handled.add(key)

    for key in sorted(box.keys()):
        if key in handled or key == "patcher":
            continue
        parts.append(f"{key}={_format_value(box[key])}")

    return f"Box({', '.join(parts)})", post_assign


def _build_boxes_block(box_entries: list) -> tuple[str, dict[str, str]]:
    lines: list[str] = []
    id_map: dict[str, str] = {}
    for idx, entry in enumerate(box_entries, start=1):
        box_data = entry.get("box", {})
        box_id = box_data.get("id", f"obj-{idx}")
        var_name = f"obj_{idx}"
        id_map[box_id] = var_name
        box_repr, post_assign = _format_box(box_data)
        lines.append(f"    {var_name} = p.add_box({box_repr})")
        for attr, value in post_assign.items():
            lines.append(f"    {var_name}.{attr} = {_format_value(value)}")
    return ("\n".join(lines) + ("\n" if lines else ""), id_map)


def _build_lines_block(lines_data: list, id_var_map: dict[str, str]) -> str:
    lines_out: list[str] = []
    for idx, entry in enumerate(lines_data, start=1):
        line_data = entry.get("patchline", {})
        source = line_data.get("source", [None, 0])
        dest = line_data.get("destination", [None, 0])
        src_id = source[0]
        src_outlet = source[1] if len(source) > 1 else 0
        dst_id = dest[0]
        dst_inlet = dest[1] if len(dest) > 1 else 0

        var_name = f"line_{idx}"
        lines_out.append(
            f"    {var_name} = p.add_patchline('{src_id}', {src_outlet}, '{dst_id}', {dst_inlet})"
        )

        for key, value in line_data.items():
            if key in {"source", "destination"}:
                continue
            formatted = _format_value(value)
            if "\n" in formatted:
                formatted = formatted.replace("\n", "\n        ")
            lines_out.append(f"    {var_name}.{key} = {formatted}")

    return "\n".join(lines_out) + ("\n" if lines_out else "")


def maxpat_to_python(
    source: str | Path,
    destination: str | Path,
    default_output: Optional[str] = None,
) -> Path:
    """Convert a ``.maxpat`` file into a standalone Python script.

    Args:
        source: Path to the source `.maxpat` file.
        destination: Path where the Python script will be written.
        default_output: Default output path baked into the generated script.

    Returns:
        Path to the generated Python script.
    """

    source_path = Path(source)
    dest_path = Path(destination)

    with source_path.open(encoding="utf8") as fh:
        payload = json.load(fh)

    if "patcher" not in payload:
        raise ValueError(f"File {source_path} does not appear to be a .maxpat file")

    patcher_dict = payload["patcher"]

    default_output_repr = repr(default_output or f"{source_path.stem}.maxpat")

    patcher_attr_block = _build_patcher_attribute_block(patcher_dict)
    box_block, id_var_map = _build_boxes_block(patcher_dict.get("boxes", []))
    line_block = _build_lines_block(patcher_dict.get("lines", []), id_var_map)

    module_text = PY_TEMPLATE.format(
        source_name=source_path.name,
        default_output_repr=default_output_repr,
        patcher_attr_block=patcher_attr_block,
        box_block=box_block,
        line_block=line_block,
    )

    module_text = textwrap.dedent(module_text)

    if dest_path.parent:
        dest_path.parent.mkdir(parents=True, exist_ok=True)

    dest_path.write_text(module_text, encoding="utf8")
    return dest_path


__all__ = ["maxpat_to_python", "maxref_to_sqlite"]


def _infer_category(ref_path: Path, data: dict) -> str:
    parts = {part.lower() for part in ref_path.parts}
    if "jit-ref" in parts or "jit" in parts:
        return "jit"
    if "msp-ref" in parts or "msp" in parts:
        return "msp"
    if "m4l-ref" in parts or "m4l" in parts:
        return "m4l"
    if "max-ref" in parts or "max" in parts:
        return "max"

    module = (data.get("module") or "").lower()
    if module in {"jit", "msp", "m4l", "max"}:
        return module

    tags = data.get("metadata", {}).get("tag")
    if isinstance(tags, list):
        for tag in tags:
            lowered = str(tag).lower()
            if lowered in {"jit", "msp", "m4l", "max"}:
                return lowered
    elif isinstance(tags, str):
        lowered = tags.lower()
        if lowered in {"jit", "msp", "m4l", "max"}:
            return lowered

    return "unknown"


def maxref_to_sqlite(
    sqlite_path: str | Path,
    names: Optional[Iterable[str]] = None,
    overwrite: bool = False,
) -> int:
    """Populate an SQLite database with maxref metadata.

    Args:
        sqlite_path: Destination SQLite file path.
        names: Optional iterable of object names to include. Defaults to all available.
        overwrite: Whether to remove any existing database before writing.

    Returns:
        Number of maxref records written.
    """

    path = Path(sqlite_path)
    if overwrite and path.exists():
        path.unlink()

    cache = MaxRefCache()
    if names is None:
        selected = sorted(cache.refdict.keys())
    else:
        selected = list(names)

    if not selected:
        return 0

    path.parent.mkdir(parents=True, exist_ok=True)
    conn = sqlite3.connect(path)
    try:
        with conn:
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS maxref (
                    name TEXT PRIMARY KEY,
                    category TEXT,
                    digest TEXT,
                    description TEXT,
                    data TEXT NOT NULL
                )
                """
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_maxref_category ON maxref(category)"
            )

            rows = []
            for name in selected:
                data = cache.get_object_data(name)
                if not data:
                    continue
                category = _infer_category(cache.refdict.get(name, Path()), data)
                digest = data.get("digest", "")
                description = data.get("description", "")
                rows.append((name, category, digest, description, json.dumps(data)))

            if not rows:
                return 0

            conn.executemany(
                """
                REPLACE INTO maxref (name, category, digest, description, data)
                VALUES (?, ?, ?, ?, ?)
                """,
                rows,
            )

        return len(rows)
    finally:
        conn.close()
