"""Utilities for converting between Max patch formats."""

from __future__ import annotations

import json
import sqlite3
import textwrap
from pathlib import Path
from typing import Iterable, Optional

from .core import Patcher
from .maxref import MaxRefCache

PY_TEMPLATE = '''"""Auto-generated by py2max. Recreates {source_name} using py2max."""
from __future__ import annotations

from py2max import Box, Patcher
from py2max.common import Rect

{helper_functions_block}

def build(output_path: str = {default_output_repr}) -> Patcher:
    """Rebuild the patcher and write it to ``output_path``."""
    p = Patcher(output_path)
{patcher_attr_block}
{box_block}
{line_block}
    p.save_as(output_path)
    return p


if __name__ == "__main__":
    build()
'''


def _format_rect(rect: object) -> str:
    if isinstance(rect, dict):
        x = rect.get("x", 0.0)
        y = rect.get("y", 0.0)
        w = rect.get("w", 0.0)
        h = rect.get("h", 0.0)
    elif isinstance(rect, (list, tuple)) and len(rect) == 4:
        x, y, w, h = rect
    else:
        raise ValueError(f"Unsupported rect value: {rect}")
    return f"Rect({x}, {y}, {w}, {h})"


def _format_value(value: object) -> str:
    if isinstance(value, str):
        return repr(value)
    if isinstance(value, (int, float, bool)) or value is None:
        return repr(value)
    if isinstance(value, (list, tuple, dict)):
        return repr(value)
    return repr(value)


def _build_subpatch_function(name: str, patcher_dict: dict, ctx: _CodeGenContext) -> str:
    attr_block, box_block, line_block, _ = _build_patcher_sections(
        patcher_dict, ctx, "sp", f"{name}_obj", "    "
    )
    body = (
        f"def {name}() -> Patcher:\n"
        f"    sp = Patcher()\n"
        f"{attr_block}{box_block}{line_block}"
        "    return sp\n"
    )
    return body


def _build_patcher_attribute_lines(
    patcher_dict: dict, patcher_var: str, indent: str
) -> str:
    lines: list[str] = []
    keys_present: set[str] = set()
    for key, value in patcher_dict.items():
        if key in {"boxes", "lines"}:
            continue
        if key.startswith("_"):
            continue
        if key == "rect":
            formatted = _format_rect(value)
        else:
            formatted = _format_value(value)
        line = f"{indent}{patcher_var}.{key} = {formatted}"
        lines.append(line)
        keys_present.add(key)
    missing = sorted(_DEFAULT_PUBLIC_ATTRS - keys_present)
    for key in missing:
        lines.append(f"{indent}if hasattr({patcher_var}, '{key}'):")
        lines.append(f"{indent}    delattr({patcher_var}, '{key}')")
    return "\n".join(lines) + ("\n" if lines else "")


def _format_box(box: dict) -> tuple[str, dict[str, object]]:
    if "patcher" in box:
        raise NotImplementedError("Subpatcher conversion is not yet supported")

    key_order = [
        "id",
        "maxclass",
        "text",
        "numinlets",
        "numoutlets",
        "outlettype",
        "patching_rect",
    ]

    parts: list[str] = []
    handled = set()
    post_assign: dict[str, object] = {}
    for key in key_order:
        if key not in box:
            continue
        value = box[key]
        if key == "patching_rect":
            formatted = _format_rect(value)
        elif key == "numoutlets" and value == 0:
            post_assign[key] = value
            handled.add(key)
            continue
        else:
            formatted = _format_value(value)
        parts.append(f"{key}={formatted}")
        handled.add(key)

    for key in sorted(box.keys()):
        if key in handled or key == "patcher":
            continue
        parts.append(f"{key}={_format_value(box[key])}")

    return f"Box({', '.join(parts)})", post_assign


class _CodeGenContext:
    def __init__(self):
        self.counter = 0
        self.helper_functions: list[str] = []

    def new_subpatch_name(self) -> str:
        name = f"_build_subpatch_{self.counter}"
        self.counter += 1
        return name


def _build_patcher_sections(
    patcher_dict: dict,
    ctx: _CodeGenContext,
    patcher_var: str,
    obj_prefix: str,
    indent: str,
) -> tuple[str, str, str, dict[str, str]]:
    attr_block = _build_patcher_attribute_lines(patcher_dict, patcher_var, indent)
    box_block, id_map = _build_boxes_block(
        patcher_dict.get("boxes", []), ctx, patcher_var, obj_prefix, indent
    )
    line_block = _build_lines_block(
        patcher_dict.get("lines", []), id_map, patcher_var, indent
    )
    return attr_block, box_block, line_block, id_map


def _build_boxes_block(
    box_entries: list,
    ctx: _CodeGenContext,
    patcher_var: str,
    obj_prefix: str,
    indent: str,
) -> tuple[str, dict[str, str]]:
    lines: list[str] = []
    id_map: dict[str, str] = {}
    for idx, entry in enumerate(box_entries, start=1):
        box_data = dict(entry.get("box", {}))
        box_id = box_data.get("id", f"obj-{idx}")
        var_name = f"{obj_prefix}_{idx}"
        id_map[box_id] = var_name
        subpatch_dict = box_data.pop("patcher", None)
        box_repr, post_assign = _format_box(box_data)
        lines.append(f"{indent}{var_name} = {patcher_var}.add_box({box_repr})")
        for attr, value in post_assign.items():
            lines.append(f"{indent}{var_name}.{attr} = {_format_value(value)}")
        if subpatch_dict:
            func_name = ctx.new_subpatch_name()
            helper = _build_subpatch_function(func_name, subpatch_dict, ctx)
            ctx.helper_functions.append(helper)
            lines.append(f"{indent}{var_name}._patcher = {func_name}()")
            lines.append(f"{indent}{var_name}._patcher._parent = {patcher_var}")
    return ("\n".join(lines) + ("\n" if lines else ""), id_map)


def _build_lines_block(
    lines_data: list, id_var_map: dict[str, str], patcher_var: str, indent: str
) -> str:
    lines_out: list[str] = []
    for idx, entry in enumerate(lines_data, start=1):
        line_data = entry.get("patchline", {})
        source = line_data.get("source", [None, 0])
        dest = line_data.get("destination", [None, 0])
        src_id = source[0]
        src_outlet = source[1] if len(source) > 1 else 0
        dst_id = dest[0]
        dst_inlet = dest[1] if len(dest) > 1 else 0

        var_name = f"line_{idx}"
        lines_out.append(
            f"{indent}{var_name} = {patcher_var}.add_patchline('{src_id}', {src_outlet}, '{dst_id}', {dst_inlet})"
        )

        for key, value in line_data.items():
            if key in {"source", "destination"}:
                continue
            formatted = _format_value(value)
            lines_out.append(f"{indent}{var_name}.{key} = {formatted}")

    return "\n".join(lines_out) + ("\n" if lines_out else "")


def maxpat_to_python(
    source: str | Path,
    destination: str | Path,
    default_output: Optional[str] = None,
) -> Path:
    """Convert a ``.maxpat`` file into a standalone Python script.

    Args:
        source: Path to the source `.maxpat` file.
        destination: Path where the Python script will be written.
        default_output: Default output path baked into the generated script.

    Returns:
        Path to the generated Python script.
    """

    source_path = Path(source)
    dest_path = Path(destination)

    with source_path.open(encoding="utf8") as fh:
        payload = json.load(fh)

    if "patcher" not in payload:
        raise ValueError(f"File {source_path} does not appear to be a .maxpat file")

    patcher_dict = payload["patcher"]

    default_output_repr = repr(default_output or f"{source_path.stem}.maxpat")

    ctx = _CodeGenContext()
    patcher_attr_block, box_block, line_block, _ = _build_patcher_sections(
        patcher_dict, ctx, "p", "obj", "    "
    )
    helper_functions_block = "\n".join(ctx.helper_functions)
    if helper_functions_block:
        helper_functions_block += "\n\n"

    module_text = PY_TEMPLATE.format(
        source_name=source_path.name,
        default_output_repr=default_output_repr,
        patcher_attr_block=patcher_attr_block,
        box_block=box_block,
        line_block=line_block,
        helper_functions_block=helper_functions_block,
    )

    module_text = textwrap.dedent(module_text)

    if dest_path.parent:
        dest_path.parent.mkdir(parents=True, exist_ok=True)

    dest_path.write_text(module_text, encoding="utf8")
    return dest_path


__all__ = ["maxpat_to_python", "maxref_to_sqlite"]


def _infer_category(ref_path: Path, data: dict) -> str:
    parts = {part.lower() for part in ref_path.parts}
    if "jit-ref" in parts or "jit" in parts:
        return "jit"
    if "msp-ref" in parts or "msp" in parts:
        return "msp"
    if "m4l-ref" in parts or "m4l" in parts:
        return "m4l"
    if "max-ref" in parts or "max" in parts:
        return "max"

    module = (data.get("module") or "").lower()
    if module in {"jit", "msp", "m4l", "max"}:
        return module

    tags = data.get("metadata", {}).get("tag")
    if isinstance(tags, list):
        for tag in tags:
            lowered = str(tag).lower()
            if lowered in {"jit", "msp", "m4l", "max"}:
                return lowered
    elif isinstance(tags, str):
        lowered = tags.lower()
        if lowered in {"jit", "msp", "m4l", "max"}:
            return lowered

    return "unknown"


def maxref_to_sqlite(
    sqlite_path: str | Path,
    names: Optional[Iterable[str]] = None,
    overwrite: bool = False,
) -> int:
    """Populate an SQLite database with maxref metadata.

    Args:
        sqlite_path: Destination SQLite file path.
        names: Optional iterable of object names to include. Defaults to all available.
        overwrite: Whether to remove any existing database before writing.

    Returns:
        Number of maxref records written.
    """

    path = Path(sqlite_path)
    if overwrite and path.exists():
        path.unlink()

    cache = MaxRefCache()
    if names is None:
        selected = sorted(cache.refdict.keys())
    else:
        selected = list(names)

    if not selected:
        return 0

    path.parent.mkdir(parents=True, exist_ok=True)
    conn = sqlite3.connect(path)
    try:
        with conn:
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS maxref (
                    name TEXT PRIMARY KEY,
                    category TEXT,
                    digest TEXT,
                    description TEXT,
                    data TEXT NOT NULL
                )
                """
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_maxref_category ON maxref(category)"
            )

            rows = []
            for name in selected:
                data = cache.get_object_data(name)
                if not data:
                    continue
                category = _infer_category(cache.refdict.get(name, Path()), data)
                digest = data.get("digest", "")
                description = data.get("description", "")
                rows.append((name, category, digest, description, json.dumps(data)))

            if not rows:
                return 0

            conn.executemany(
                """
                REPLACE INTO maxref (name, category, digest, description, data)
                VALUES (?, ?, ?, ?, ?)
                """,
                rows,
            )

        return len(rows)
    finally:
        conn.close()
_DEFAULT_PUBLIC_ATTRS = {
    name
    for name in vars(Patcher()).keys()
    if not name.startswith("_") and name not in {"boxes", "lines"}
}
